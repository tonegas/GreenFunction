// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GREENFUNCTION_GREENFUNCTION_H_
#define FLATBUFFERS_GENERATED_GREENFUNCTION_GREENFUNCTION_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace GreenFunction {

struct GreenStructIn;

struct GreenStructOut;

struct IGreen;
struct IGreenBuilder;
struct IGreenT;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) GreenStructIn FLATBUFFERS_FINAL_CLASS {
 private:
  double ecu_up_time_;
  double ego_velocity_;
  int32_t adasis_curvature_nrs_;
  int32_t padding0__;
  double adasis_curvature_dist_[100];
  double adasis_curvature_values_[100];
  double lane_width_;
  int32_t adasis_speed_limits_nrs_;
  int32_t padding1__;
  double adasis_speed_limit_dist_[10];
  int32_t adasis_speed_limit_values_[10];

 public:
  GreenStructIn()
      : ecu_up_time_(0),
        ego_velocity_(0),
        adasis_curvature_nrs_(0),
        padding0__(0),
        adasis_curvature_dist_(),
        adasis_curvature_values_(),
        lane_width_(0),
        adasis_speed_limits_nrs_(0),
        padding1__(0),
        adasis_speed_limit_dist_(),
        adasis_speed_limit_values_() {
    (void)padding0__;
    (void)padding1__;
  }
  GreenStructIn(double _ecu_up_time, double _ego_velocity, int32_t _adasis_curvature_nrs, double _lane_width, int32_t _adasis_speed_limits_nrs)
      : ecu_up_time_(::flatbuffers::EndianScalar(_ecu_up_time)),
        ego_velocity_(::flatbuffers::EndianScalar(_ego_velocity)),
        adasis_curvature_nrs_(::flatbuffers::EndianScalar(_adasis_curvature_nrs)),
        padding0__(0),
        adasis_curvature_dist_(),
        adasis_curvature_values_(),
        lane_width_(::flatbuffers::EndianScalar(_lane_width)),
        adasis_speed_limits_nrs_(::flatbuffers::EndianScalar(_adasis_speed_limits_nrs)),
        padding1__(0),
        adasis_speed_limit_dist_(),
        adasis_speed_limit_values_() {
    (void)padding0__;
    (void)padding1__;
  }
  GreenStructIn(double _ecu_up_time, double _ego_velocity, int32_t _adasis_curvature_nrs, ::flatbuffers::span<const double, 100> _adasis_curvature_dist, ::flatbuffers::span<const double, 100> _adasis_curvature_values, double _lane_width, int32_t _adasis_speed_limits_nrs, ::flatbuffers::span<const double, 10> _adasis_speed_limit_dist, ::flatbuffers::span<const int32_t, 10> _adasis_speed_limit_values)
      : ecu_up_time_(::flatbuffers::EndianScalar(_ecu_up_time)),
        ego_velocity_(::flatbuffers::EndianScalar(_ego_velocity)),
        adasis_curvature_nrs_(::flatbuffers::EndianScalar(_adasis_curvature_nrs)),
        padding0__(0),
        lane_width_(::flatbuffers::EndianScalar(_lane_width)),
        adasis_speed_limits_nrs_(::flatbuffers::EndianScalar(_adasis_speed_limits_nrs)),
        padding1__(0) {
    (void)padding0__;
    ::flatbuffers::CastToArray(adasis_curvature_dist_).CopyFromSpan(_adasis_curvature_dist);
    ::flatbuffers::CastToArray(adasis_curvature_values_).CopyFromSpan(_adasis_curvature_values);
    (void)padding1__;
    ::flatbuffers::CastToArray(adasis_speed_limit_dist_).CopyFromSpan(_adasis_speed_limit_dist);
    ::flatbuffers::CastToArray(adasis_speed_limit_values_).CopyFromSpan(_adasis_speed_limit_values);
  }
  /// Means system up-time second [s]
  double ecu_up_time() const {
    return ::flatbuffers::EndianScalar(ecu_up_time_);
  }
  /// Ego velocity
  double ego_velocity() const {
    return ::flatbuffers::EndianScalar(ego_velocity_);
  }
  /// Number of filled element inside CurvatureDist and CurvatureValues
  int32_t adasis_curvature_nrs() const {
    return ::flatbuffers::EndianScalar(adasis_curvature_nrs_);
  }
  /// Vector of distances for the curvatures in meters [m]
  const ::flatbuffers::Array<double, 100> *adasis_curvature_dist() const {
    return &::flatbuffers::CastToArray(adasis_curvature_dist_);
  }
  /// Vector of curvatures (positive for left curves) [1/m]
  const ::flatbuffers::Array<double, 100> *adasis_curvature_values() const {
    return &::flatbuffers::CastToArray(adasis_curvature_values_);
  }
  /// Width of the lane in meters [m]
  double lane_width() const {
    return ::flatbuffers::EndianScalar(lane_width_);
  }
  /// Number of filled element inside AdasisSpeedLimitDist and AdasisSpeedLimitValues
  int32_t adasis_speed_limits_nrs() const {
    return ::flatbuffers::EndianScalar(adasis_speed_limits_nrs_);
  }
  /// Vector of distance for the speed limits if is negative means that the vehicle in inside a speed limit [m]
  const ::flatbuffers::Array<double, 10> *adasis_speed_limit_dist() const {
    return &::flatbuffers::CastToArray(adasis_speed_limit_dist_);
  }
  /// Vector of speedlimit in km [km/h]
  const ::flatbuffers::Array<int32_t, 10> *adasis_speed_limit_values() const {
    return &::flatbuffers::CastToArray(adasis_speed_limit_values_);
  }
};
FLATBUFFERS_STRUCT_END(GreenStructIn, 1760);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) GreenStructOut FLATBUFFERS_FINAL_CLASS {
 private:
  double ecu_up_time_;
  double t0_;
  double velocity_profile_times_[20];
  double velocity_profile_values_[20];
  double cost_manoeuvre_;

 public:
  GreenStructOut()
      : ecu_up_time_(0),
        t0_(0),
        velocity_profile_times_(),
        velocity_profile_values_(),
        cost_manoeuvre_(0) {
  }
  GreenStructOut(double _ecu_up_time, double _t0, double _cost_manoeuvre)
      : ecu_up_time_(::flatbuffers::EndianScalar(_ecu_up_time)),
        t0_(::flatbuffers::EndianScalar(_t0)),
        velocity_profile_times_(),
        velocity_profile_values_(),
        cost_manoeuvre_(::flatbuffers::EndianScalar(_cost_manoeuvre)) {
  }
  GreenStructOut(double _ecu_up_time, double _t0, ::flatbuffers::span<const double, 20> _velocity_profile_times, ::flatbuffers::span<const double, 20> _velocity_profile_values, double _cost_manoeuvre)
      : ecu_up_time_(::flatbuffers::EndianScalar(_ecu_up_time)),
        t0_(::flatbuffers::EndianScalar(_t0)),
        cost_manoeuvre_(::flatbuffers::EndianScalar(_cost_manoeuvre)) {
    ::flatbuffers::CastToArray(velocity_profile_times_).CopyFromSpan(_velocity_profile_times);
    ::flatbuffers::CastToArray(velocity_profile_values_).CopyFromSpan(_velocity_profile_values);
  }
  /// Means system up-time second [s]
  double ecu_up_time() const {
    return ::flatbuffers::EndianScalar(ecu_up_time_);
  }
  /// ECU up time when the primitive starts (based on ECUs given by Scenario Messages)
  double t0() const {
    return ::flatbuffers::EndianScalar(t0_);
  }
  /// Vector of times for the velocity profile
  const ::flatbuffers::Array<double, 20> *velocity_profile_times() const {
    return &::flatbuffers::CastToArray(velocity_profile_times_);
  }
  /// Vector of velocity profile
  const ::flatbuffers::Array<double, 20> *velocity_profile_values() const {
    return &::flatbuffers::CastToArray(velocity_profile_values_);
  }
  /// Cost of the manoeuvre
  double cost_manoeuvre() const {
    return ::flatbuffers::EndianScalar(cost_manoeuvre_);
  }
};
FLATBUFFERS_STRUCT_END(GreenStructOut, 344);

struct IGreenT : public ::flatbuffers::NativeTable {
  typedef IGreen TableType;
  uint64_t cycle_number = 0;
  std::unique_ptr<GreenFunction::GreenStructIn> in{};
  std::unique_ptr<GreenFunction::GreenStructOut> out{};
  IGreenT() = default;
  IGreenT(const IGreenT &o);
  IGreenT(IGreenT&&) FLATBUFFERS_NOEXCEPT = default;
  IGreenT &operator=(IGreenT o) FLATBUFFERS_NOEXCEPT;
};

struct IGreen FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IGreenT NativeTableType;
  typedef IGreenBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CYCLE_NUMBER = 4,
    VT_IN = 6,
    VT_OUT = 8
  };
  /// Packet Identifier. Must be related to the packet GreenStructIn
  uint64_t cycle_number() const {
    return GetField<uint64_t>(VT_CYCLE_NUMBER, 0);
  }
  const GreenFunction::GreenStructIn *in() const {
    return GetStruct<const GreenFunction::GreenStructIn *>(VT_IN);
  }
  const GreenFunction::GreenStructOut *out() const {
    return GetStruct<const GreenFunction::GreenStructOut *>(VT_OUT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_CYCLE_NUMBER, 8) &&
           VerifyField<GreenFunction::GreenStructIn>(verifier, VT_IN, 8) &&
           VerifyField<GreenFunction::GreenStructOut>(verifier, VT_OUT, 8) &&
           verifier.EndTable();
  }
  IGreenT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IGreenT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<IGreen> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const IGreenT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IGreenBuilder {
  typedef IGreen Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_cycle_number(uint64_t cycle_number) {
    fbb_.AddElement<uint64_t>(IGreen::VT_CYCLE_NUMBER, cycle_number, 0);
  }
  void add_in(const GreenFunction::GreenStructIn *in) {
    fbb_.AddStruct(IGreen::VT_IN, in);
  }
  void add_out(const GreenFunction::GreenStructOut *out) {
    fbb_.AddStruct(IGreen::VT_OUT, out);
  }
  explicit IGreenBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IGreen> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IGreen>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IGreen> CreateIGreen(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t cycle_number = 0,
    const GreenFunction::GreenStructIn *in = nullptr,
    const GreenFunction::GreenStructOut *out = nullptr) {
  IGreenBuilder builder_(_fbb);
  builder_.add_cycle_number(cycle_number);
  builder_.add_out(out);
  builder_.add_in(in);
  return builder_.Finish();
}

::flatbuffers::Offset<IGreen> CreateIGreen(::flatbuffers::FlatBufferBuilder &_fbb, const IGreenT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline IGreenT::IGreenT(const IGreenT &o)
      : cycle_number(o.cycle_number),
        in((o.in) ? new GreenFunction::GreenStructIn(*o.in) : nullptr),
        out((o.out) ? new GreenFunction::GreenStructOut(*o.out) : nullptr) {
}

inline IGreenT &IGreenT::operator=(IGreenT o) FLATBUFFERS_NOEXCEPT {
  std::swap(cycle_number, o.cycle_number);
  std::swap(in, o.in);
  std::swap(out, o.out);
  return *this;
}

inline IGreenT *IGreen::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<IGreenT>(new IGreenT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void IGreen::UnPackTo(IGreenT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cycle_number(); _o->cycle_number = _e; }
  { auto _e = in(); if (_e) _o->in = std::unique_ptr<GreenFunction::GreenStructIn>(new GreenFunction::GreenStructIn(*_e)); }
  { auto _e = out(); if (_e) _o->out = std::unique_ptr<GreenFunction::GreenStructOut>(new GreenFunction::GreenStructOut(*_e)); }
}

inline ::flatbuffers::Offset<IGreen> IGreen::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const IGreenT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIGreen(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<IGreen> CreateIGreen(::flatbuffers::FlatBufferBuilder &_fbb, const IGreenT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const IGreenT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cycle_number = _o->cycle_number;
  auto _in = _o->in ? _o->in.get() : nullptr;
  auto _out = _o->out ? _o->out.get() : nullptr;
  return GreenFunction::CreateIGreen(
      _fbb,
      _cycle_number,
      _in,
      _out);
}

inline const GreenFunction::IGreen *GetIGreen(const void *buf) {
  return ::flatbuffers::GetRoot<GreenFunction::IGreen>(buf);
}

inline const GreenFunction::IGreen *GetSizePrefixedIGreen(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<GreenFunction::IGreen>(buf);
}

inline bool VerifyIGreenBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<GreenFunction::IGreen>(nullptr);
}

inline bool VerifySizePrefixedIGreenBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<GreenFunction::IGreen>(nullptr);
}

inline void FinishIGreenBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<GreenFunction::IGreen> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedIGreenBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<GreenFunction::IGreen> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<GreenFunction::IGreenT> UnPackIGreen(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<GreenFunction::IGreenT>(GetIGreen(buf)->UnPack(res));
}

inline std::unique_ptr<GreenFunction::IGreenT> UnPackSizePrefixedIGreen(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<GreenFunction::IGreenT>(GetSizePrefixedIGreen(buf)->UnPack(res));
}

}  // namespace GreenFunction

#endif  // FLATBUFFERS_GENERATED_GREENFUNCTION_GREENFUNCTION_H_
